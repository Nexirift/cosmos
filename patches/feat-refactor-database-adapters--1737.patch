diff --color --color -Naru a/dist/adapters/drizzle-adapter/index.cjs b/dist/adapters/drizzle-adapter/index.cjs
--- a/dist/adapters/drizzle-adapter/index.cjs	2025-03-17 17:23:39.304302126 +1030
+++ b/dist/adapters/drizzle-adapter/index.cjs	2025-03-17 17:26:05.914805023 +1030
@@ -37,7 +37,7 @@
     const schema2 = config.schema || db._.fullSchema;
     if (!schema2) {
       throw new index.BetterAuthError(
-        "Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
+        "[# Drizzle Adapter]: Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
       );
     }
     const model = getModelName(modelName);
@@ -52,70 +52,79 @@
   const getModelName = (model) => {
     return schema[model].modelName !== model ? schema[model].modelName : config.usePlural ? `${model}s` : model;
   };
-  function convertWhereClause(where, model) {
+  function convertWhereClause(model, where) {
+    if (!where || !where.length) return [];
     const schemaModel = getSchema(model);
-    if (!where) return [];
-    if (where.length === 1) {
-      const w = where[0];
-      if (!w) {
-        return [];
-      }
+    const conditions = where.map((w) => {
       const field = getField(model, w.field);
       if (!schemaModel[field]) {
         throw new index.BetterAuthError(
-          `The field "${w.field}" does not exist in the schema for the model "${model}". Please update your schema.`
+          `[# Drizzle Adapter]: The field "${w.field}" does not exist in the schema for the model "${model}". Please update your schema.`
         );
       }
-      if (w.operator === "in") {
-        if (!Array.isArray(w.value)) {
+      const { value, operator = "eq", connector } = w;
+      let condition;
+      switch (operator) {
+        case "eq":
+          condition = drizzleOrm.eq(schemaModel[field], value);
+          break;
+        case "ne":
+          condition = drizzleOrm.ne(schemaModel[field], value);
+          break;
+        case "lt":
+          condition = drizzleOrm.lt(schemaModel[field], value);
+          break;
+        case "lte":
+          condition = drizzleOrm.lte(schemaModel[field], value);
+          break;
+        case "gt":
+          condition = drizzleOrm.gt(schemaModel[field], value);
+          break;
+        case "gte":
+          condition = drizzleOrm.gte(schemaModel[field], value);
+          break;
+        case "in":
+          if (!Array.isArray(value)) {
+            throw new index.BetterAuthError(
+              `[# Drizzle Adapter]: The value for the field "${w.field}" must be an array when using the "in" operator.`
+            );
+          }
+          condition = drizzleOrm.inArray(schemaModel[field], value);
+          break;
+        case "contains":
+          condition = drizzleOrm.like(schemaModel[field], `%${value}%`);
+          break;
+        case "starts_with":
+          condition = drizzleOrm.like(schemaModel[field], `${value}%`);
+          break;
+        case "ends_with":
+          condition = drizzleOrm.like(schemaModel[field], `%${value}`);
+          break;
+        default:
           throw new index.BetterAuthError(
-            `The value for the field "${w.field}" must be an array when using the "in" operator.`
+            `[# Drizzle Adapter]: Unsupported operator: ${operator}`
           );
-        }
-        return [drizzleOrm.inArray(schemaModel[field], w.value)];
       }
-      if (w.operator === "contains") {
-        return [drizzleOrm.like(schemaModel[field], `%${w.value}%`)];
-      }
-      if (w.operator === "starts_with") {
-        return [drizzleOrm.like(schemaModel[field], `${w.value}%`)];
-      }
-      if (w.operator === "ends_with") {
-        return [drizzleOrm.like(schemaModel[field], `%${w.value}`)];
-      }
-      if (w.operator === "lt") {
-        return [drizzleOrm.lt(schemaModel[field], w.value)];
+      return { condition, connector };
+    });
+    if (conditions.length === 1) {
+      return [conditions[0].condition];
+    }
+    const andConditions = conditions.filter((c) => c.connector === "AND" || !c.connector).map((c) => c.condition);
+    const orConditions = conditions.filter((c) => c.connector === "OR").map((c) => c.condition);
+    const clause = [];
+    if (andConditions.length) {
+      const andClause = drizzleOrm.and(...andConditions);
+      if (andClause) {
+        clause.push(andClause);
       }
-      if (w.operator === "lte") {
-        return [drizzleOrm.lte(schemaModel[field], w.value)];
+    }
+    if (orConditions.length) {
+      const orClause = drizzleOrm.or(...orConditions);
+      if (orClause) {
+        clause.push(orClause);
       }
-      return [drizzleOrm.eq(schemaModel[field], w.value)];
     }
-    const andGroup = where.filter((w) => w.connector === "AND" || !w.connector);
-    const orGroup = where.filter((w) => w.connector === "OR");
-    const andClause = drizzleOrm.and(
-      ...andGroup.map((w) => {
-        const field = getField(model, w.field);
-        if (w.operator === "in") {
-          if (!Array.isArray(w.value)) {
-            throw new index.BetterAuthError(
-              `The value for the field "${w.field}" must be an array when using the "in" operator.`
-            );
-          }
-          return drizzleOrm.inArray(schemaModel[field], w.value);
-        }
-        return drizzleOrm.eq(schemaModel[field], w.value);
-      })
-    );
-    const orClause = drizzleOrm.or(
-      ...orGroup.map((w) => {
-        const field = getField(model, w.field);
-        return drizzleOrm.eq(schemaModel[field], w.value);
-      })
-    );
-    const clause = [];
-    if (andGroup.length) clause.push(andClause);
-    if (orGroup.length) clause.push(orClause);
     return clause;
   }
   const useDatabaseGeneratedId = options?.advanced?.generateId === false;
@@ -168,7 +177,7 @@
       const schemaModel = getSchema(model);
       const builderVal = builder.config?.values;
       if (where?.length) {
-        const clause = convertWhereClause(where, model);
+        const clause = convertWhereClause(model, where);
         const res = await db.select().from(schemaModel).where(...clause);
         return res[0];
       } else if (builderVal) {
@@ -187,13 +196,13 @@
 function checkMissingFields(schema, model, values) {
   if (!schema) {
     throw new index.BetterAuthError(
-      "Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
+      "[# Drizzle Adapter]: Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
     );
   }
   for (const key in values) {
     if (!schema[key]) {
       throw new index.BetterAuthError(
-        `The field "${key}" does not exist in the "${model}" schema. Please update your drizzle schema or re-generate using "npx @better-auth/cli generate".`
+        `[# Drizzle Adapter]: The field "${key}" does not exist in the "${model}" schema. Please update your drizzle schema or re-generate using "npx @better-auth/cli generate".`
       );
     }
   }
@@ -222,7 +231,7 @@
     async findOne(data) {
       const { model, where, select } = data;
       const schemaModel = getSchema(model);
-      const clause = convertWhereClause(where, model);
+      const clause = convertWhereClause(model, where);
       const res = await db.select().from(schemaModel).where(...clause);
       if (!res.length) return null;
       return transformOutput(res[0], model, select);
@@ -230,7 +239,7 @@
     async findMany(data) {
       const { model, where, sortBy, limit, offset } = data;
       const schemaModel = getSchema(model);
-      const clause = where ? convertWhereClause(where, model) : [];
+      const clause = where ? convertWhereClause(model, where) : [];
       const sortFn = sortBy?.direction === "desc" ? drizzleOrm.desc : drizzleOrm.asc;
       const builder = db.select().from(schemaModel).limit(limit || 100).offset(offset || 0);
       if (sortBy?.field) {
@@ -242,14 +251,14 @@
     async count(data) {
       const { model, where } = data;
       const schemaModel = getSchema(model);
-      const clause = where ? convertWhereClause(where, model) : [];
+      const clause = where ? convertWhereClause(model, where) : [];
       const res = await db.select({ count: drizzleOrm.count() }).from(schemaModel).where(...clause);
-      return res.count;
+      return res[0].count;
     },
     async update(data) {
       const { model, where, update: values } = data;
       const schemaModel = getSchema(model);
-      const clause = convertWhereClause(where, model);
+      const clause = convertWhereClause(model, where);
       const transformed = transformInput(values, model, "update");
       const builder = db.update(schemaModel).set(transformed).where(...clause);
       const returned = await withReturning(
@@ -263,7 +272,7 @@
     async updateMany(data) {
       const { model, where, update: values } = data;
       const schemaModel = getSchema(model);
-      const clause = convertWhereClause(where, model);
+      const clause = convertWhereClause(model, where);
       const transformed = transformInput(values, model, "update");
       const builder = db.update(schemaModel).set(transformed).where(...clause);
       const res = await builder;
@@ -272,14 +281,14 @@
     async delete(data) {
       const { model, where } = data;
       const schemaModel = getSchema(model);
-      const clause = convertWhereClause(where, model);
+      const clause = convertWhereClause(model, where);
       const builder = db.delete(schemaModel).where(...clause);
       await builder;
     },
     async deleteMany(data) {
       const { model, where } = data;
       const schemaModel = getSchema(model);
-      const clause = convertWhereClause(where, model);
+      const clause = convertWhereClause(model, where);
       const builder = db.delete(schemaModel).where(...clause);
       const res = await builder;
       return res ? res.length : 0;
diff --color --color -Naru a/dist/adapters/drizzle-adapter/index.mjs b/dist/adapters/drizzle-adapter/index.mjs
--- a/dist/adapters/drizzle-adapter/index.mjs	2025-03-17 17:23:39.351770865 +1030
+++ b/dist/adapters/drizzle-adapter/index.mjs	2025-03-17 17:26:05.970805415 +1030
@@ -1,4 +1,4 @@
-import { count, desc, asc, eq, inArray, like, lt, lte, and, or } from 'drizzle-orm';
+import { count, desc, asc, eq, like, inArray, gte, gt, lte, lt, ne, and, or } from 'drizzle-orm';
 import '../../shared/better-auth.C24Bzw4w.mjs';
 import '../../shared/better-auth.8zoxzg-F.mjs';
 import { g as generateId } from '../../shared/better-auth.BUPPRXfK.mjs';
@@ -35,7 +35,7 @@
     const schema2 = config.schema || db._.fullSchema;
     if (!schema2) {
       throw new BetterAuthError(
-        "Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
+        "[# Drizzle Adapter]: Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
       );
     }
     const model = getModelName(modelName);
@@ -50,70 +50,79 @@
   const getModelName = (model) => {
     return schema[model].modelName !== model ? schema[model].modelName : config.usePlural ? `${model}s` : model;
   };
-  function convertWhereClause(where, model) {
+  function convertWhereClause(model, where) {
+    if (!where || !where.length) return [];
     const schemaModel = getSchema(model);
-    if (!where) return [];
-    if (where.length === 1) {
-      const w = where[0];
-      if (!w) {
-        return [];
-      }
+    const conditions = where.map((w) => {
       const field = getField(model, w.field);
       if (!schemaModel[field]) {
         throw new BetterAuthError(
-          `The field "${w.field}" does not exist in the schema for the model "${model}". Please update your schema.`
+          `[# Drizzle Adapter]: The field "${w.field}" does not exist in the schema for the model "${model}". Please update your schema.`
         );
       }
-      if (w.operator === "in") {
-        if (!Array.isArray(w.value)) {
+      const { value, operator = "eq", connector } = w;
+      let condition;
+      switch (operator) {
+        case "eq":
+          condition = eq(schemaModel[field], value);
+          break;
+        case "ne":
+          condition = ne(schemaModel[field], value);
+          break;
+        case "lt":
+          condition = lt(schemaModel[field], value);
+          break;
+        case "lte":
+          condition = lte(schemaModel[field], value);
+          break;
+        case "gt":
+          condition = gt(schemaModel[field], value);
+          break;
+        case "gte":
+          condition = gte(schemaModel[field], value);
+          break;
+        case "in":
+          if (!Array.isArray(value)) {
+            throw new BetterAuthError(
+              `[# Drizzle Adapter]: The value for the field "${w.field}" must be an array when using the "in" operator.`
+            );
+          }
+          condition = inArray(schemaModel[field], value);
+          break;
+        case "contains":
+          condition = like(schemaModel[field], `%${value}%`);
+          break;
+        case "starts_with":
+          condition = like(schemaModel[field], `${value}%`);
+          break;
+        case "ends_with":
+          condition = like(schemaModel[field], `%${value}`);
+          break;
+        default:
           throw new BetterAuthError(
-            `The value for the field "${w.field}" must be an array when using the "in" operator.`
+            `[# Drizzle Adapter]: Unsupported operator: ${operator}`
           );
-        }
-        return [inArray(schemaModel[field], w.value)];
       }
-      if (w.operator === "contains") {
-        return [like(schemaModel[field], `%${w.value}%`)];
-      }
-      if (w.operator === "starts_with") {
-        return [like(schemaModel[field], `${w.value}%`)];
-      }
-      if (w.operator === "ends_with") {
-        return [like(schemaModel[field], `%${w.value}`)];
-      }
-      if (w.operator === "lt") {
-        return [lt(schemaModel[field], w.value)];
+      return { condition, connector };
+    });
+    if (conditions.length === 1) {
+      return [conditions[0].condition];
+    }
+    const andConditions = conditions.filter((c) => c.connector === "AND" || !c.connector).map((c) => c.condition);
+    const orConditions = conditions.filter((c) => c.connector === "OR").map((c) => c.condition);
+    const clause = [];
+    if (andConditions.length) {
+      const andClause = and(...andConditions);
+      if (andClause) {
+        clause.push(andClause);
       }
-      if (w.operator === "lte") {
-        return [lte(schemaModel[field], w.value)];
+    }
+    if (orConditions.length) {
+      const orClause = or(...orConditions);
+      if (orClause) {
+        clause.push(orClause);
       }
-      return [eq(schemaModel[field], w.value)];
     }
-    const andGroup = where.filter((w) => w.connector === "AND" || !w.connector);
-    const orGroup = where.filter((w) => w.connector === "OR");
-    const andClause = and(
-      ...andGroup.map((w) => {
-        const field = getField(model, w.field);
-        if (w.operator === "in") {
-          if (!Array.isArray(w.value)) {
-            throw new BetterAuthError(
-              `The value for the field "${w.field}" must be an array when using the "in" operator.`
-            );
-          }
-          return inArray(schemaModel[field], w.value);
-        }
-        return eq(schemaModel[field], w.value);
-      })
-    );
-    const orClause = or(
-      ...orGroup.map((w) => {
-        const field = getField(model, w.field);
-        return eq(schemaModel[field], w.value);
-      })
-    );
-    const clause = [];
-    if (andGroup.length) clause.push(andClause);
-    if (orGroup.length) clause.push(orClause);
     return clause;
   }
   const useDatabaseGeneratedId = options?.advanced?.generateId === false;
@@ -166,7 +175,7 @@
       const schemaModel = getSchema(model);
       const builderVal = builder.config?.values;
       if (where?.length) {
-        const clause = convertWhereClause(where, model);
+        const clause = convertWhereClause(model, where);
         const res = await db.select().from(schemaModel).where(...clause);
         return res[0];
       } else if (builderVal) {
@@ -185,13 +194,13 @@
 function checkMissingFields(schema, model, values) {
   if (!schema) {
     throw new BetterAuthError(
-      "Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
+      "[# Drizzle Adapter]: Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
     );
   }
   for (const key in values) {
     if (!schema[key]) {
       throw new BetterAuthError(
-        `The field "${key}" does not exist in the "${model}" schema. Please update your drizzle schema or re-generate using "npx @better-auth/cli generate".`
+        `[# Drizzle Adapter]: The field "${key}" does not exist in the "${model}" schema. Please update your drizzle schema or re-generate using "npx @better-auth/cli generate".`
       );
     }
   }
@@ -220,7 +229,7 @@
     async findOne(data) {
       const { model, where, select } = data;
       const schemaModel = getSchema(model);
-      const clause = convertWhereClause(where, model);
+      const clause = convertWhereClause(model, where);
       const res = await db.select().from(schemaModel).where(...clause);
       if (!res.length) return null;
       return transformOutput(res[0], model, select);
@@ -228,7 +237,7 @@
     async findMany(data) {
       const { model, where, sortBy, limit, offset } = data;
       const schemaModel = getSchema(model);
-      const clause = where ? convertWhereClause(where, model) : [];
+      const clause = where ? convertWhereClause(model, where) : [];
       const sortFn = sortBy?.direction === "desc" ? desc : asc;
       const builder = db.select().from(schemaModel).limit(limit || 100).offset(offset || 0);
       if (sortBy?.field) {
@@ -240,14 +249,14 @@
     async count(data) {
       const { model, where } = data;
       const schemaModel = getSchema(model);
-      const clause = where ? convertWhereClause(where, model) : [];
+      const clause = where ? convertWhereClause(model, where) : [];
       const res = await db.select({ count: count() }).from(schemaModel).where(...clause);
-      return res.count;
+      return res[0].count;
     },
     async update(data) {
       const { model, where, update: values } = data;
       const schemaModel = getSchema(model);
-      const clause = convertWhereClause(where, model);
+      const clause = convertWhereClause(model, where);
       const transformed = transformInput(values, model, "update");
       const builder = db.update(schemaModel).set(transformed).where(...clause);
       const returned = await withReturning(
@@ -261,7 +270,7 @@
     async updateMany(data) {
       const { model, where, update: values } = data;
       const schemaModel = getSchema(model);
-      const clause = convertWhereClause(where, model);
+      const clause = convertWhereClause(model, where);
       const transformed = transformInput(values, model, "update");
       const builder = db.update(schemaModel).set(transformed).where(...clause);
       const res = await builder;
@@ -270,14 +279,14 @@
     async delete(data) {
       const { model, where } = data;
       const schemaModel = getSchema(model);
-      const clause = convertWhereClause(where, model);
+      const clause = convertWhereClause(model, where);
       const builder = db.delete(schemaModel).where(...clause);
       await builder;
     },
     async deleteMany(data) {
       const { model, where } = data;
       const schemaModel = getSchema(model);
-      const clause = convertWhereClause(where, model);
+      const clause = convertWhereClause(model, where);
       const builder = db.delete(schemaModel).where(...clause);
       const res = await builder;
       return res ? res.length : 0;
diff --color --color -Naru a/dist/adapters/memory-adapter/index.cjs b/dist/adapters/memory-adapter/index.cjs
--- a/dist/adapters/memory-adapter/index.cjs	2025-03-17 17:23:39.304302126 +1030
+++ b/dist/adapters/memory-adapter/index.cjs	2025-03-17 17:26:05.914805023 +1030
@@ -1,6 +1,6 @@
 'use strict';

-const memoryAdapter = require('../../shared/better-auth.DZnoWLte.cjs');
+const memoryAdapter = require('../../shared/better-auth.ChJS4XXu.cjs');
 require('../../shared/better-auth.CHyZMcYK.cjs');
 require('zod');
 require('better-call');
diff --color --color -Naru a/dist/adapters/memory-adapter/index.d.cts b/dist/adapters/memory-adapter/index.d.cts
--- a/dist/adapters/memory-adapter/index.d.cts	2025-03-17 17:24:01.829930486 +1030
+++ b/dist/adapters/memory-adapter/index.d.cts	2025-03-17 17:26:28.758964929 +1030
@@ -32,7 +32,7 @@
         };
         offset?: number;
     }) => Promise<any[]>;
-    count: ({ model }: {
+    count: ({ model, where }: {
         model: string;
         where?: Where[];
     }) => Promise<number>;
diff --color --color -Naru a/dist/adapters/memory-adapter/index.d.mts b/dist/adapters/memory-adapter/index.d.mts
--- a/dist/adapters/memory-adapter/index.d.mts	2025-03-17 17:24:02.105932444 +1030
+++ b/dist/adapters/memory-adapter/index.d.mts	2025-03-17 17:26:29.078967167 +1030
@@ -32,7 +32,7 @@
         };
         offset?: number;
     }) => Promise<any[]>;
-    count: ({ model }: {
+    count: ({ model, where }: {
         model: string;
         where?: Where[];
     }) => Promise<number>;
diff --color --color -Naru a/dist/adapters/memory-adapter/index.d.ts b/dist/adapters/memory-adapter/index.d.ts
--- a/dist/adapters/memory-adapter/index.d.ts	2025-03-17 17:24:02.371934330 +1030
+++ b/dist/adapters/memory-adapter/index.d.ts	2025-03-17 17:26:29.362969152 +1030
@@ -32,7 +32,7 @@
         };
         offset?: number;
     }) => Promise<any[]>;
-    count: ({ model }: {
+    count: ({ model, where }: {
         model: string;
         where?: Where[];
     }) => Promise<number>;
diff --color --color -Naru a/dist/adapters/memory-adapter/index.mjs b/dist/adapters/memory-adapter/index.mjs
--- a/dist/adapters/memory-adapter/index.mjs	2025-03-17 17:23:39.351770865 +1030
+++ b/dist/adapters/memory-adapter/index.mjs	2025-03-17 17:26:05.970805415 +1030
@@ -1,4 +1,4 @@
-export { m as memoryAdapter } from '../../shared/better-auth.D8LeJoj0.mjs';
+export { m as memoryAdapter } from '../../shared/better-auth.DTRqoMXa.mjs';
 import '../../shared/better-auth.C24Bzw4w.mjs';
 import 'zod';
 import 'better-call';
diff --color --color -Naru a/dist/adapters/mongodb-adapter/index.cjs b/dist/adapters/mongodb-adapter/index.cjs
--- a/dist/adapters/mongodb-adapter/index.cjs	2025-03-17 17:23:39.304302126 +1030
+++ b/dist/adapters/mongodb-adapter/index.cjs	2025-03-17 17:26:05.914805023 +1030
@@ -19,6 +19,7 @@
 require('../../shared/better-auth.CYeOI8C-.cjs');
 require('../../shared/better-auth.GpOOav9x.cjs');
 const getTables = require('../../shared/better-auth.BEphVDyL.cjs');
+const index = require('../../shared/better-auth.ANpbi45u.cjs');
 require('kysely');
 const utils = require('../../shared/better-auth.CUdxApHl.cjs');

@@ -46,10 +47,10 @@
             if (v instanceof mongodb.ObjectId) {
               return v;
             }
-            throw new Error("Invalid id value");
+            throw new index.BetterAuthError("[# Mongodb Adapter]: Invalid id value");
           });
         }
-        throw new Error("Invalid id value");
+        throw new index.BetterAuthError("[# Mongodb Adapter]: Invalid id value");
       }
       try {
         return new mongodb.ObjectId(value);
@@ -130,16 +131,19 @@
       }
       return transformedData;
     },
-    convertWhereClause(where, model) {
+    convertWhereClause(model, where) {
       if (!where.length) return {};
       const conditions = where.map((w) => {
         const { field: _field, value, operator = "eq", connector = "AND" } = w;
         let condition;
         const field = getField(_field, model);
+        function escapeRegex(value2) {
+          return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
+        }
         switch (operator.toLowerCase()) {
           case "eq":
             condition = {
-              [field]: serializeID(_field, value, model)
+              [field]: { $eq: serializeID(_field, value, model) }
             };
             break;
           case "in":
@@ -165,16 +169,33 @@
             condition = { [field]: { $ne: value } };
             break;
           case "contains":
-            condition = { [field]: { $regex: `.*${value}.*` } };
+            if (typeof value !== "string") {
+              throw new index.BetterAuthError(
+                `[# Mongodb Adapter]: contains operator requires a string but was provided ${typeof value}`
+              );
+            }
+            condition = { [field]: { $regex: escapeRegex(value) } };
             break;
           case "starts_with":
-            condition = { [field]: { $regex: `${value}.*` } };
+            if (typeof value !== "string") {
+              throw new index.BetterAuthError(
+                `[# Mongodb Adapter]: starts_with operator requires a string but was provided ${typeof value}`
+              );
+            }
+            condition = { [field]: { $regex: `^${escapeRegex(value)}` } };
             break;
           case "ends_with":
-            condition = { [field]: { $regex: `.*${value}` } };
+            if (typeof value !== "string") {
+              throw new index.BetterAuthError(
+                `[# Mongodb Adapter]: ends_with operator requires a string but was provided ${typeof value}`
+              );
+            }
+            condition = { [field]: { $regex: `${escapeRegex(value)}$` } };
             break;
           default:
-            throw new Error(`Unsupported operator: ${operator}`);
+            throw new index.BetterAuthError(
+              `[# Mongodb Adapter]: Unsupported operator: ${operator}`
+            );
         }
         return { condition, connector };
       });
@@ -217,7 +238,7 @@
     },
     async findOne(data) {
       const { model, where, select } = data;
-      const clause = transform.convertWhereClause(where, model);
+      const clause = transform.convertWhereClause(model, where);
       const res = await db.collection(transform.getModelName(model)).findOne(clause);
       if (!res) return null;
       const transformedData = transform.transformOutput(res, model, select);
@@ -225,7 +246,7 @@
     },
     async findMany(data) {
       const { model, where, limit, offset, sortBy } = data;
-      const clause = where ? transform.convertWhereClause(where, model) : {};
+      const clause = where ? transform.convertWhereClause(model, where) : {};
       const cursor = db.collection(transform.getModelName(model)).find(clause);
       if (limit) cursor.limit(limit);
       if (offset) cursor.skip(offset);
@@ -238,13 +259,14 @@
       return res.map((r) => transform.transformOutput(r, model));
     },
     async count(data) {
-      const { model } = data;
-      const res = await db.collection(transform.getModelName(model)).countDocuments();
+      const { model, where } = data;
+      const clause = where ? transform.convertWhereClause(model, where) : {};
+      const res = await db.collection(transform.getModelName(model)).countDocuments(clause);
       return res;
     },
     async update(data) {
       const { model, where, update: values } = data;
-      const clause = transform.convertWhereClause(where, model);
+      const clause = transform.convertWhereClause(model, where);
       const transformedData = transform.transformInput(values, model, "update");
       const res = await db.collection(transform.getModelName(model)).findOneAndUpdate(
         clause,
@@ -258,21 +280,21 @@
     },
     async updateMany(data) {
       const { model, where, update: values } = data;
-      const clause = transform.convertWhereClause(where, model);
+      const clause = transform.convertWhereClause(model, where);
       const transformedData = transform.transformInput(values, model, "update");
       const res = await db.collection(transform.getModelName(model)).updateMany(clause, { $set: transformedData });
       return res.modifiedCount;
     },
     async delete(data) {
       const { model, where } = data;
-      const clause = transform.convertWhereClause(where, model);
+      const clause = transform.convertWhereClause(model, where);
       const res = await db.collection(transform.getModelName(model)).findOneAndDelete(clause);
       if (!res) return null;
       return transform.transformOutput(res, model);
     },
     async deleteMany(data) {
       const { model, where } = data;
-      const clause = transform.convertWhereClause(where, model);
+      const clause = transform.convertWhereClause(model, where);
       const res = await db.collection(transform.getModelName(model)).deleteMany(clause);
       return res.deletedCount;
     }
diff --color --color -Naru a/dist/adapters/mongodb-adapter/index.mjs b/dist/adapters/mongodb-adapter/index.mjs
--- a/dist/adapters/mongodb-adapter/index.mjs	2025-03-17 17:23:39.351770865 +1030
+++ b/dist/adapters/mongodb-adapter/index.mjs	2025-03-17 17:26:05.970805415 +1030
@@ -17,6 +17,7 @@
 import '../../shared/better-auth.B4Qoxdgc.mjs';
 import '../../shared/better-auth.DH3YjMQH.mjs';
 import { g as getAuthTables } from '../../shared/better-auth.DORkW_Ge.mjs';
+import { B as BetterAuthError } from '../../shared/better-auth.DdzSJf-n.mjs';
 import 'kysely';
 import { w as withApplyDefault } from '../../shared/better-auth.0TC26uRi.mjs';

@@ -44,10 +45,10 @@
             if (v instanceof ObjectId) {
               return v;
             }
-            throw new Error("Invalid id value");
+            throw new BetterAuthError("[# Mongodb Adapter]: Invalid id value");
           });
         }
-        throw new Error("Invalid id value");
+        throw new BetterAuthError("[# Mongodb Adapter]: Invalid id value");
       }
       try {
         return new ObjectId(value);
@@ -128,16 +129,19 @@
       }
       return transformedData;
     },
-    convertWhereClause(where, model) {
+    convertWhereClause(model, where) {
       if (!where.length) return {};
       const conditions = where.map((w) => {
         const { field: _field, value, operator = "eq", connector = "AND" } = w;
         let condition;
         const field = getField(_field, model);
+        function escapeRegex(value2) {
+          return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
+        }
         switch (operator.toLowerCase()) {
           case "eq":
             condition = {
-              [field]: serializeID(_field, value, model)
+              [field]: { $eq: serializeID(_field, value, model) }
             };
             break;
           case "in":
@@ -163,16 +167,33 @@
             condition = { [field]: { $ne: value } };
             break;
           case "contains":
-            condition = { [field]: { $regex: `.*${value}.*` } };
+            if (typeof value !== "string") {
+              throw new BetterAuthError(
+                `[# Mongodb Adapter]: contains operator requires a string but was provided ${typeof value}`
+              );
+            }
+            condition = { [field]: { $regex: escapeRegex(value) } };
             break;
           case "starts_with":
-            condition = { [field]: { $regex: `${value}.*` } };
+            if (typeof value !== "string") {
+              throw new BetterAuthError(
+                `[# Mongodb Adapter]: starts_with operator requires a string but was provided ${typeof value}`
+              );
+            }
+            condition = { [field]: { $regex: `^${escapeRegex(value)}` } };
             break;
           case "ends_with":
-            condition = { [field]: { $regex: `.*${value}` } };
+            if (typeof value !== "string") {
+              throw new BetterAuthError(
+                `[# Mongodb Adapter]: ends_with operator requires a string but was provided ${typeof value}`
+              );
+            }
+            condition = { [field]: { $regex: `${escapeRegex(value)}$` } };
             break;
           default:
-            throw new Error(`Unsupported operator: ${operator}`);
+            throw new BetterAuthError(
+              `[# Mongodb Adapter]: Unsupported operator: ${operator}`
+            );
         }
         return { condition, connector };
       });
@@ -215,7 +236,7 @@
     },
     async findOne(data) {
       const { model, where, select } = data;
-      const clause = transform.convertWhereClause(where, model);
+      const clause = transform.convertWhereClause(model, where);
       const res = await db.collection(transform.getModelName(model)).findOne(clause);
       if (!res) return null;
       const transformedData = transform.transformOutput(res, model, select);
@@ -223,7 +244,7 @@
     },
     async findMany(data) {
       const { model, where, limit, offset, sortBy } = data;
-      const clause = where ? transform.convertWhereClause(where, model) : {};
+      const clause = where ? transform.convertWhereClause(model, where) : {};
       const cursor = db.collection(transform.getModelName(model)).find(clause);
       if (limit) cursor.limit(limit);
       if (offset) cursor.skip(offset);
@@ -236,13 +257,14 @@
       return res.map((r) => transform.transformOutput(r, model));
     },
     async count(data) {
-      const { model } = data;
-      const res = await db.collection(transform.getModelName(model)).countDocuments();
+      const { model, where } = data;
+      const clause = where ? transform.convertWhereClause(model, where) : {};
+      const res = await db.collection(transform.getModelName(model)).countDocuments(clause);
       return res;
     },
     async update(data) {
       const { model, where, update: values } = data;
-      const clause = transform.convertWhereClause(where, model);
+      const clause = transform.convertWhereClause(model, where);
       const transformedData = transform.transformInput(values, model, "update");
       const res = await db.collection(transform.getModelName(model)).findOneAndUpdate(
         clause,
@@ -256,21 +278,21 @@
     },
     async updateMany(data) {
       const { model, where, update: values } = data;
-      const clause = transform.convertWhereClause(where, model);
+      const clause = transform.convertWhereClause(model, where);
       const transformedData = transform.transformInput(values, model, "update");
       const res = await db.collection(transform.getModelName(model)).updateMany(clause, { $set: transformedData });
       return res.modifiedCount;
     },
     async delete(data) {
       const { model, where } = data;
-      const clause = transform.convertWhereClause(where, model);
+      const clause = transform.convertWhereClause(model, where);
       const res = await db.collection(transform.getModelName(model)).findOneAndDelete(clause);
       if (!res) return null;
       return transform.transformOutput(res, model);
     },
     async deleteMany(data) {
       const { model, where } = data;
-      const clause = transform.convertWhereClause(where, model);
+      const clause = transform.convertWhereClause(model, where);
       const res = await db.collection(transform.getModelName(model)).deleteMany(clause);
       return res.deletedCount;
     }
diff --color --color -Naru a/dist/adapters/prisma-adapter/index.cjs b/dist/adapters/prisma-adapter/index.cjs
--- a/dist/adapters/prisma-adapter/index.cjs	2025-03-17 17:23:39.304302126 +1030
+++ b/dist/adapters/prisma-adapter/index.cjs	2025-03-17 17:26:05.914805023 +1030
@@ -34,12 +34,24 @@
   }
   function operatorToPrismaOperator(operator) {
     switch (operator) {
+      case "ne":
+        return "not";
+      // lt, lte, gt, gte, in, contains operators have same name
+      case "lt":
+      case "lte":
+      case "gt":
+      case "gte":
+      case "in":
+      case "contains":
+        return operator;
       case "starts_with":
         return "startsWith";
       case "ends_with":
         return "endsWith";
       default:
-        return operator;
+        throw new index.BetterAuthError(
+          `[# Prisma Adapter]: Unsupported operator: ${operator}`
+        );
     }
   }
   function getModelName(model) {
@@ -85,34 +97,23 @@
       return transformedData;
     },
     convertWhereClause(model, where) {
-      if (!where) return {};
-      if (where.length === 1) {
-        const w = where[0];
-        if (!w) {
-          return;
-        }
-        return {
+      if (!where || !where.length) return {};
+      const conditions = where.map((w) => ({
+        condition: {
           [getField(model, w.field)]: w.operator === "eq" || !w.operator ? w.value : {
-            [operatorToPrismaOperator(w.operator)]: w.value
+            [operatorToPrismaOperator(w.operator)]: (
+              // If the operator is "in" and the value is not an array, wrap it in an array
+              w.operator === "in" && !Array.isArray(w.value) ? [w.value] : w.value
+            )
           }
-        };
+        },
+        connector: w.connector
+      }));
+      if (conditions.length === 1) {
+        return conditions[0].condition;
       }
-      const and = where.filter((w) => w.connector === "AND" || !w.connector);
-      const or = where.filter((w) => w.connector === "OR");
-      const andClause = and.map((w) => {
-        return {
-          [getField(model, w.field)]: w.operator === "eq" || !w.operator ? w.value : {
-            [operatorToPrismaOperator(w.operator)]: w.value
-          }
-        };
-      });
-      const orClause = or.map((w) => {
-        return {
-          [getField(model, w.field)]: {
-            [w.operator || "eq"]: w.value
-          }
-        };
-      });
+      const andClause = conditions.filter((c) => c.connector === "AND" || !c.connector).map((c) => c.condition);
+      const orClause = conditions.filter((c) => c.connector === "OR").map((c) => c.condition);
       return {
         ...andClause.length ? { AND: andClause } : {},
         ...orClause.length ? { OR: orClause } : {}
@@ -141,16 +142,19 @@
     getModelName,
     getField
   } = createTransform(config, options);
+  function checkModelExistsOrThrow(model) {
+    if (!db[getModelName(model)]) {
+      throw new index.BetterAuthError(
+        `[# Prisma Adapter]: Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
+      );
+    }
+  }
   return {
     id: "prisma",
     async create(data) {
       const { model, data: values, select } = data;
       const transformed = transformInput(values, model, "create");
-      if (!db[getModelName(model)]) {
-        throw new index.BetterAuthError(
-          `Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
-        );
-      }
+      checkModelExistsOrThrow(model);
       const result = await db[getModelName(model)].create({
         data: transformed,
         select: convertSelect(select, model)
@@ -160,11 +164,7 @@
     async findOne(data) {
       const { model, where, select } = data;
       const whereClause = convertWhereClause(model, where);
-      if (!db[getModelName(model)]) {
-        throw new index.BetterAuthError(
-          `Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
-        );
-      }
+      checkModelExistsOrThrow(model);
       const result = await db[getModelName(model)].findFirst({
         where: whereClause,
         select: convertSelect(select, model)
@@ -174,11 +174,7 @@
     async findMany(data) {
       const { model, where, limit, offset, sortBy } = data;
       const whereClause = convertWhereClause(model, where);
-      if (!db[getModelName(model)]) {
-        throw new index.BetterAuthError(
-          `Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
-        );
-      }
+      checkModelExistsOrThrow(model);
       const result = await db[getModelName(model)].findMany({
         where: whereClause,
         take: limit || 100,
@@ -194,11 +190,7 @@
     async count(data) {
       const { model, where } = data;
       const whereClause = convertWhereClause(model, where);
-      if (!db[getModelName(model)]) {
-        throw new index.BetterAuthError(
-          `Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
-        );
-      }
+      checkModelExistsOrThrow(model);
       const result = await db[getModelName(model)].count({
         where: whereClause
       });
@@ -206,11 +198,7 @@
     },
     async update(data) {
       const { model, where, update } = data;
-      if (!db[getModelName(model)]) {
-        throw new index.BetterAuthError(
-          `Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
-        );
-      }
+      checkModelExistsOrThrow(model);
       const whereClause = convertWhereClause(model, where);
       const transformed = transformInput(update, model, "update");
       const result = await db[getModelName(model)].update({
@@ -221,6 +209,7 @@
     },
     async updateMany(data) {
       const { model, where, update } = data;
+      checkModelExistsOrThrow(model);
       const whereClause = convertWhereClause(model, where);
       const transformed = transformInput(update, model, "update");
       const result = await db[getModelName(model)].updateMany({
@@ -231,6 +220,7 @@
     },
     async delete(data) {
       const { model, where } = data;
+      checkModelExistsOrThrow(model);
       const whereClause = convertWhereClause(model, where);
       try {
         await db[getModelName(model)].delete({
@@ -241,6 +231,7 @@
     },
     async deleteMany(data) {
       const { model, where } = data;
+      checkModelExistsOrThrow(model);
       const whereClause = convertWhereClause(model, where);
       const result = await db[getModelName(model)].deleteMany({
         where: whereClause
diff --color --color -Naru a/dist/adapters/prisma-adapter/index.mjs b/dist/adapters/prisma-adapter/index.mjs
--- a/dist/adapters/prisma-adapter/index.mjs	2025-03-17 17:23:39.351770865 +1030
+++ b/dist/adapters/prisma-adapter/index.mjs	2025-03-17 17:26:05.970805415 +1030
@@ -32,12 +32,24 @@
   }
   function operatorToPrismaOperator(operator) {
     switch (operator) {
+      case "ne":
+        return "not";
+      // lt, lte, gt, gte, in, contains operators have same name
+      case "lt":
+      case "lte":
+      case "gt":
+      case "gte":
+      case "in":
+      case "contains":
+        return operator;
       case "starts_with":
         return "startsWith";
       case "ends_with":
         return "endsWith";
       default:
-        return operator;
+        throw new BetterAuthError(
+          `[# Prisma Adapter]: Unsupported operator: ${operator}`
+        );
     }
   }
   function getModelName(model) {
@@ -83,34 +95,23 @@
       return transformedData;
     },
     convertWhereClause(model, where) {
-      if (!where) return {};
-      if (where.length === 1) {
-        const w = where[0];
-        if (!w) {
-          return;
-        }
-        return {
+      if (!where || !where.length) return {};
+      const conditions = where.map((w) => ({
+        condition: {
           [getField(model, w.field)]: w.operator === "eq" || !w.operator ? w.value : {
-            [operatorToPrismaOperator(w.operator)]: w.value
+            [operatorToPrismaOperator(w.operator)]: (
+              // If the operator is "in" and the value is not an array, wrap it in an array
+              w.operator === "in" && !Array.isArray(w.value) ? [w.value] : w.value
+            )
           }
-        };
+        },
+        connector: w.connector
+      }));
+      if (conditions.length === 1) {
+        return conditions[0].condition;
       }
-      const and = where.filter((w) => w.connector === "AND" || !w.connector);
-      const or = where.filter((w) => w.connector === "OR");
-      const andClause = and.map((w) => {
-        return {
-          [getField(model, w.field)]: w.operator === "eq" || !w.operator ? w.value : {
-            [operatorToPrismaOperator(w.operator)]: w.value
-          }
-        };
-      });
-      const orClause = or.map((w) => {
-        return {
-          [getField(model, w.field)]: {
-            [w.operator || "eq"]: w.value
-          }
-        };
-      });
+      const andClause = conditions.filter((c) => c.connector === "AND" || !c.connector).map((c) => c.condition);
+      const orClause = conditions.filter((c) => c.connector === "OR").map((c) => c.condition);
       return {
         ...andClause.length ? { AND: andClause } : {},
         ...orClause.length ? { OR: orClause } : {}
@@ -139,16 +140,19 @@
     getModelName,
     getField
   } = createTransform(config, options);
+  function checkModelExistsOrThrow(model) {
+    if (!db[getModelName(model)]) {
+      throw new BetterAuthError(
+        `[# Prisma Adapter]: Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
+      );
+    }
+  }
   return {
     id: "prisma",
     async create(data) {
       const { model, data: values, select } = data;
       const transformed = transformInput(values, model, "create");
-      if (!db[getModelName(model)]) {
-        throw new BetterAuthError(
-          `Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
-        );
-      }
+      checkModelExistsOrThrow(model);
       const result = await db[getModelName(model)].create({
         data: transformed,
         select: convertSelect(select, model)
@@ -158,11 +162,7 @@
     async findOne(data) {
       const { model, where, select } = data;
       const whereClause = convertWhereClause(model, where);
-      if (!db[getModelName(model)]) {
-        throw new BetterAuthError(
-          `Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
-        );
-      }
+      checkModelExistsOrThrow(model);
       const result = await db[getModelName(model)].findFirst({
         where: whereClause,
         select: convertSelect(select, model)
@@ -172,11 +172,7 @@
     async findMany(data) {
       const { model, where, limit, offset, sortBy } = data;
       const whereClause = convertWhereClause(model, where);
-      if (!db[getModelName(model)]) {
-        throw new BetterAuthError(
-          `Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
-        );
-      }
+      checkModelExistsOrThrow(model);
       const result = await db[getModelName(model)].findMany({
         where: whereClause,
         take: limit || 100,
@@ -192,11 +188,7 @@
     async count(data) {
       const { model, where } = data;
       const whereClause = convertWhereClause(model, where);
-      if (!db[getModelName(model)]) {
-        throw new BetterAuthError(
-          `Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
-        );
-      }
+      checkModelExistsOrThrow(model);
       const result = await db[getModelName(model)].count({
         where: whereClause
       });
@@ -204,11 +196,7 @@
     },
     async update(data) {
       const { model, where, update } = data;
-      if (!db[getModelName(model)]) {
-        throw new BetterAuthError(
-          `Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`
-        );
-      }
+      checkModelExistsOrThrow(model);
       const whereClause = convertWhereClause(model, where);
       const transformed = transformInput(update, model, "update");
       const result = await db[getModelName(model)].update({
@@ -219,6 +207,7 @@
     },
     async updateMany(data) {
       const { model, where, update } = data;
+      checkModelExistsOrThrow(model);
       const whereClause = convertWhereClause(model, where);
       const transformed = transformInput(update, model, "update");
       const result = await db[getModelName(model)].updateMany({
@@ -229,6 +218,7 @@
     },
     async delete(data) {
       const { model, where } = data;
+      checkModelExistsOrThrow(model);
       const whereClause = convertWhereClause(model, where);
       try {
         await db[getModelName(model)].delete({
@@ -239,6 +229,7 @@
     },
     async deleteMany(data) {
       const { model, where } = data;
+      checkModelExistsOrThrow(model);
       const whereClause = convertWhereClause(model, where);
       const result = await db[getModelName(model)].deleteMany({
         where: whereClause
diff --color --color -Naru a/dist/adapters/test.cjs b/dist/adapters/test.cjs
--- a/dist/adapters/test.cjs	2025-03-17 17:23:39.304302126 +1030
+++ b/dist/adapters/test.cjs	2025-03-17 17:26:05.914805023 +1030
@@ -184,7 +184,7 @@
         createdAt: /* @__PURE__ */ new Date(),
         updatedAt: /* @__PURE__ */ new Date(),
         userId: user2.id,
-        expiresAt: /* @__PURE__ */ new Date()
+        expiresAt: new Date(Date.now() + 1e3 * 60 * 20)
       }
     });
     token = session.token;
@@ -287,6 +287,24 @@
       email: "updated@email.com"
     });
   });
+  vitest.test("should count records", async () => {
+    const res = await adapter.count({
+      model: "user"
+    });
+    vitest.expect(res).toBe(5);
+  });
+  vitest.test("should count records with where", async () => {
+    const res = await adapter.count({
+      model: "user",
+      where: [
+        {
+          field: "id",
+          value: user.id
+        }
+      ]
+    });
+    vitest.expect(res).toBe(1);
+  });
   vitest.test("delete model", async () => {
     await adapter.delete({
       model: "user",
@@ -375,6 +393,120 @@
     });
     vitest.expect(res).toBeNull();
   });
+  vitest.test("should not find user with ne operator", async () => {
+    const user2 = await adapter.create({
+      model: "user",
+      data: {
+        id: "6",
+        name: "testuserop",
+        email: "test-userop@email.com",
+        emailVerified: true,
+        createdAt: /* @__PURE__ */ new Date(),
+        updatedAt: /* @__PURE__ */ new Date()
+      }
+    });
+    const res = await adapter.findMany({
+      model: "user",
+      where: [
+        {
+          field: "email",
+          operator: "ne",
+          value: "test-userop@email.com"
+        }
+      ]
+    });
+    vitest.expect(res).not.toContainEqual(user2);
+  });
+  vitest.test("should find user with eq operator", async () => {
+    const res = await adapter.findOne({
+      model: "user",
+      where: [
+        {
+          field: "email",
+          operator: "eq",
+          value: "test-userop@email.com"
+        }
+      ]
+    });
+    vitest.expect(res?.email).toBe("test-userop@email.com");
+  });
+  vitest.test("should find user with no(undefined) operator", async () => {
+    const res = await adapter.findOne({
+      model: "user",
+      where: [
+        {
+          field: "email",
+          value: "test-userop@email.com"
+        }
+      ]
+    });
+    vitest.expect(res?.email).toBe("test-userop@email.com");
+  });
+  vitest.test("should find session with lt operator", async () => {
+    const res = await adapter.findMany({
+      model: "session",
+      where: [
+        {
+          field: "createdAt",
+          operator: "lt",
+          value: /* @__PURE__ */ new Date()
+        }
+      ]
+    });
+    vitest.expect(res.length).toBe(1);
+  });
+  vitest.test("should find session with lte operator", async () => {
+    const res = await adapter.findMany({
+      model: "session",
+      where: [
+        {
+          field: "createdAt",
+          operator: "lte",
+          value: /* @__PURE__ */ new Date()
+        }
+      ]
+    });
+    vitest.expect(res.length).toBe(1);
+  });
+  vitest.test("should find session with gt operator", async () => {
+    const res = await adapter.findMany({
+      model: "session",
+      where: [
+        {
+          field: "expiresAt",
+          operator: "gt",
+          value: /* @__PURE__ */ new Date()
+        }
+      ]
+    });
+    vitest.expect(res.length).toBe(1);
+  });
+  vitest.test("should find session with gte operator", async () => {
+    const res = await adapter.findMany({
+      model: "session",
+      where: [
+        {
+          field: "expiresAt",
+          operator: "gte",
+          value: /* @__PURE__ */ new Date()
+        }
+      ]
+    });
+    vitest.expect(res.length).toBe(1);
+  });
+  vitest.test("should find user with in operator", async () => {
+    const res = await adapter.findMany({
+      model: "user",
+      where: [
+        {
+          field: "email",
+          operator: "in",
+          value: ["test-userop@email.com", "test@email.com"]
+        }
+      ]
+    });
+    vitest.expect(res.length).toBe(2);
+  });
   vitest.test("should find many with contains operator", async () => {
     const res = await adapter.findMany({
       model: "user",
diff --color --color -Naru a/dist/adapters/test.mjs b/dist/adapters/test.mjs
--- a/dist/adapters/test.mjs	2025-03-17 17:23:39.351770865 +1030
+++ b/dist/adapters/test.mjs	2025-03-17 17:26:05.970805415 +1030
@@ -182,7 +182,7 @@
         createdAt: /* @__PURE__ */ new Date(),
         updatedAt: /* @__PURE__ */ new Date(),
         userId: user2.id,
-        expiresAt: /* @__PURE__ */ new Date()
+        expiresAt: new Date(Date.now() + 1e3 * 60 * 20)
       }
     });
     token = session.token;
@@ -285,6 +285,24 @@
       email: "updated@email.com"
     });
   });
+  test("should count records", async () => {
+    const res = await adapter.count({
+      model: "user"
+    });
+    expect(res).toBe(5);
+  });
+  test("should count records with where", async () => {
+    const res = await adapter.count({
+      model: "user",
+      where: [
+        {
+          field: "id",
+          value: user.id
+        }
+      ]
+    });
+    expect(res).toBe(1);
+  });
   test("delete model", async () => {
     await adapter.delete({
       model: "user",
@@ -373,6 +391,120 @@
     });
     expect(res).toBeNull();
   });
+  test("should not find user with ne operator", async () => {
+    const user2 = await adapter.create({
+      model: "user",
+      data: {
+        id: "6",
+        name: "testuserop",
+        email: "test-userop@email.com",
+        emailVerified: true,
+        createdAt: /* @__PURE__ */ new Date(),
+        updatedAt: /* @__PURE__ */ new Date()
+      }
+    });
+    const res = await adapter.findMany({
+      model: "user",
+      where: [
+        {
+          field: "email",
+          operator: "ne",
+          value: "test-userop@email.com"
+        }
+      ]
+    });
+    expect(res).not.toContainEqual(user2);
+  });
+  test("should find user with eq operator", async () => {
+    const res = await adapter.findOne({
+      model: "user",
+      where: [
+        {
+          field: "email",
+          operator: "eq",
+          value: "test-userop@email.com"
+        }
+      ]
+    });
+    expect(res?.email).toBe("test-userop@email.com");
+  });
+  test("should find user with no(undefined) operator", async () => {
+    const res = await adapter.findOne({
+      model: "user",
+      where: [
+        {
+          field: "email",
+          value: "test-userop@email.com"
+        }
+      ]
+    });
+    expect(res?.email).toBe("test-userop@email.com");
+  });
+  test("should find session with lt operator", async () => {
+    const res = await adapter.findMany({
+      model: "session",
+      where: [
+        {
+          field: "createdAt",
+          operator: "lt",
+          value: /* @__PURE__ */ new Date()
+        }
+      ]
+    });
+    expect(res.length).toBe(1);
+  });
+  test("should find session with lte operator", async () => {
+    const res = await adapter.findMany({
+      model: "session",
+      where: [
+        {
+          field: "createdAt",
+          operator: "lte",
+          value: /* @__PURE__ */ new Date()
+        }
+      ]
+    });
+    expect(res.length).toBe(1);
+  });
+  test("should find session with gt operator", async () => {
+    const res = await adapter.findMany({
+      model: "session",
+      where: [
+        {
+          field: "expiresAt",
+          operator: "gt",
+          value: /* @__PURE__ */ new Date()
+        }
+      ]
+    });
+    expect(res.length).toBe(1);
+  });
+  test("should find session with gte operator", async () => {
+    const res = await adapter.findMany({
+      model: "session",
+      where: [
+        {
+          field: "expiresAt",
+          operator: "gte",
+          value: /* @__PURE__ */ new Date()
+        }
+      ]
+    });
+    expect(res.length).toBe(1);
+  });
+  test("should find user with in operator", async () => {
+    const res = await adapter.findMany({
+      model: "user",
+      where: [
+        {
+          field: "email",
+          operator: "in",
+          value: ["test-userop@email.com", "test@email.com"]
+        }
+      ]
+    });
+    expect(res.length).toBe(2);
+  });
   test("should find many with contains operator", async () => {
     const res = await adapter.findMany({
       model: "user",
